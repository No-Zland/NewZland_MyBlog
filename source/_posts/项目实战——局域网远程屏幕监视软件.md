---
title: 项目实战——局域网远程屏幕监视软件
date: 2025-08-07 13:04:18
tags:
---

## 前言
免责声明，本项目仅用于学习与交流讨论，不可用于任何违法或盈利行为。

## 目录
- 前言
- 一、项目简介
- 二、项目效果
- 三、技术支持
- 四、环境搭建
- 五、开发流程
- 六、总结

## 一、项目简介
- 服务端可发起远程屏幕监视，实时接收并显示客户端的屏幕画面，同时显示帧率和图像大小。
- 支持监视过程的主动退出（服务端按 ESC 键终止）。

该项目的使用需要服务端与客户端处于同一局域网下，且需要客户端点开软件。此时客户端不会有任何提示。客户端重启电脑或关机时需要重新打开软件。

## 二、项目效果
![img](tmp/124938950146_docx.datword_media_image1.jpeg)

## 三、技术支持
- 编程语言：Python
- 网络通信：基于socket库实现 TCP/IP 协议的客户端 - 服务端（C/S）通信（可靠传输适合数据完整性要求高的场景，如文件传输）。
- 系统控制：通过os.system调用系统命令（针对 Windows 系统的shutdown命令实现关机 / 重启）。
- 屏幕捕捉：使用PIL.ImageGrab库实现客户端屏幕实时截屏。
- 图像显示与处理：通过OpenCV（cv2）库在服务端接收并显示图像，同时计算和展示帧率。
- 时间控制：使用time库实现帧率限制和时间计算。

## 四、环境搭建
- 硬件支持：Window系统
- 开发软件：Vscode
- 编译环境：Python11.3
- 第三方库：moviepy--1.0.3、requests、DrissionPage、pillow、pyinstaller、opencv-python

## 五、开发流程

### （一）第三方库安装
Win+R打开运行弹窗，在弹窗输入框中输入cmd（或CMD）

![img](运行Windows 将根据你所输入的名称,为你打开相应的程序、文件夹、文档或 Internet 资源。打开(O):cmd确定取消浏览(B)...)[![img](tmp/124938950146_docx.datword_media_image3.gif)​编辑](tmp/124938950146_docx.datword_media_image3.gif)

![img](□x C:\WINDOWS\system32\cmd.X Microsoft Windows [版本 10.0.26100.4652] Microsoft Corporation。保留所有权利。C:\Users\19826>)[![img](tmp/124938950146_docx.datword_media_image3.gif)​编辑](tmp/124938950146_docx.datword_media_image3.gif)

在上面界面分别输入以下pip指令
```
pip install moviepy--1.0.3
pip install requests
pip install DrissionPage
pip install pillow
pip install pyinstaller
pip install opencv-python
```

完成第三方库的安装后打开VScode，在VScode中新建项目，在项目中新建两份.py文档（服务端.py、客户端.py）

### （二）服务端搭建

#### 1.网络通信基础模块
（1）服务端配置：创建 Socket，绑定端口（1024~35565），这里选择10061，监听连接，接收客户端连接后建立通信链路。
```python
# 服务端.py
from socket import *
import cv2
import time

S = socket()
S.bind(('0.0.0.0', 10061))
S.listen()
s, addr = S.accept()
```
![img](tmp/124938950146_docx.datword_media_image3.gif)

#### 2.屏幕监视模块
（1）指令发送：定义一个变量作为启动客户端监视的发送指令，同时发送该指令后开始接受客户端的屏幕传输。
```python
if choice == '1':
    print("开始远程监视，按ESC键退出")
    frame_count = 0
    start_time = time.time()
```
![img](tmp/124938950146_docx.datword_media_image3.gif)

（2）数据接收：先读取带\n的文件大小，确认后按大小接收完整图像数据并保存为本地文件。（2）（3）（4）代码在while循环内。
```python
# 接收图片大小
size_data = b''
while True: # 实现不断监视
    chunk = s.recv(1)
    if chunk == b'\n':  
        break
    size_data += chunk
            
    try:
        size = int(size_data.decode())
    except ValueError:
        print("无效的图片大小数据，断开连接")
        break
            
    # 发送确认
    s.send(b'ok')
        
    # 接收图片数据
    cursize = 0
    filename = f'frame_{frame_count}.jpg'
    with open(filename, 'wb') as file:
        while cursize < size:
            chunk = s.recv(min(2048, size - cursize))
            if not chunk:
                break
            file.write(chunk)
            cursize += len(chunk)
```
![img](tmp/124938950146_docx.datword_media_image3.gif)

（3）图像显示：用cv2.imread读取图像，通过cv2.imshow显示，叠加帧率和大小信息（putText），同时处理图片异常情况。
```python
# 显示图片
try:
    image = cv2.imread(filename)
    if image is not None:
         cv2.imshow('Remote Control', image)
                    
         # 显示帧率信息
         frame_count += 1
         elapsed = time.time() - start_time
         fps = frame_count / elapsed if elapsed > 0 else 0
         fps_text = f"FPS: {fps:.1f} | Size: {size//1024}KB"
         cv2.putText(image, fps_text, (10, 30), 
             cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
         cv2.imshow('Remote Control', image)
     else:
         print("无法读取图片文件")
except Exception as e:
     print(f"显示图片错误: {e}")
```
![img](tmp/124938950146_docx.datword_media_image3.gif)

（4）退出控制：监听 ESC 键（waitKey(1) == 27），发送exit指令终止客户端传输，否则继续。
```python
# 检查退出键（ESC）
if cv2.waitKey(1) == 27:
    print("用户退出远程监视")
    s.send(b'exit')
    break
                
# 发送确认继续
s.send(b'ok')
```
![img](tmp/124938950146_docx.datword_media_image3.gif)

（5）释放窗口资源：
```python
finally:
    cv2.destroyAllWindows()
```
![img](tmp/124938950146_docx.datword_media_image3.gif)

### （三）客户端搭建

#### 1.网络通信基础模块
（1）客户端配置：创建 Socket，连接服务端 IP （这里测试使用回送地址，监视需使用实际地址）和端口（需与服务端一致），建立双向通信。
```python
# 客户端.py
import os
import time
from socket import *
from PIL import ImageGrab

s = socket()
s.connect(('107.0.0.1', 10061))  # 替换为实际服务端IP
```
![img](tmp/124938950146_docx.datword_media_image3.gif)

#### 2.屏幕监视模块
（1）指令接收：定义一个变量接收服务端定义的发送指令后开始触发客户端开始屏幕传输。
```python
choice = s.recv(1024).decode()
if choice == '3':
    frame_count = 0
    start_time = time.time()
```
![img](tmp/124938950146_docx.datword_media_image3.gif)

（2）循环截屏：使用ImageGrab.grab()获取屏幕画面，调整尺寸（960x540）减少数据量。该部分以下全部程序在while循环内。
```python
image = ImageGrab.grab()
image = image.resize((960, 540))
```
![img](tmp/124938950146_docx.datword_media_image3.gif)

（3）数据预处理：将图像保存为临时 JPG 文件（控制质量quality=85进一步压缩）。
```python
temp_file = f'temp_{frame_count}.jpg'
image.save(temp_file, quality=85) 
```
![img](tmp/124938950146_docx.datword_media_image3.gif)

（4）数据传输：先发送文件大小（带\n结束符），等待服务端确认（ok）后（因为图像数据较大）分块发送文件内容，完成后删除临时文件以节省内存。
```python
size = os.path.getsize(temp_file)
s.send(f"{size}\n".encode())

# 等待服务端确认
response = s.recv(1024)
if response != b'ok':
    print(f"服务端响应异常: {response}")
    break
                
# 分块发送图片数据
with open(temp_file, 'rb') as file:
    while True:
        data = file.read(2048)
        if not data:
            break
        s.send(data)

# 删除临时文件
os.remove(temp_file)
```
![img](tmp/124938950146_docx.datword_media_image3.gif)

（5）流程控制：接收服务端响应（ok继续 /exit退出），通过sleep控制帧率不超过 15FPS（人眼感知度上限为15FPS~24FPS），避免数据堆积与延迟，同时减少对网络宽带与内存的占用。
```python
response = s.recv(1024)
if response == b'exit':
    print("服务端请求退出")
    break
elif response != b'ok':
    print(f"服务端响应异常: {response}")
    break
```
![img](tmp/124938950146_docx.datword_media_image3.gif)

### （四）软件打包
找到文件的位置，右键打开终端

![img](名称类型大小修改日期文件夹build2025/7/16 12:56dist2025/7/16 12:56文件夹Qiu2025/7/13 23:37JPG文件71 KB服务端2025/7/16 12:58PY 文件3 KBPY 文件3 KB客户端2025/7/16 12:55品8查看>排序方式>Ξ分组依据>V撤消 删除Ctrl+Z新建属性Alt+Enter在终端中打开显示更多选项)[![img](tmp/124938950146_docx.datword_media_image3.gif)​](tmp/124938950146_docx.datword_media_image3.gif)

在终端输入指令pyinstaller -F -w -i ，随后用Tab键找到需要作为软件图标的图片，再继续用Tab键找到客服端的代码，回车键后进行打包。

![img](tmp/124938950146_docx.datword_media_image6.png)[![img](tmp/124938950146_docx.datword_media_image3.gif)​](tmp/124938950146_docx.datword_media_image3.gif)

随后打开该目录下的dist文件夹，后缀为.exe的文件便是打包好的软件。

## 六、总结
这个项目有很大的局限性，比如说仅限于同一局域网、无法做到自行启动等等。可以在合法的情形进行研究。对网络安全技术提升有很大的帮助